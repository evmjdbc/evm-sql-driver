package com.evmjdbc.connection

import com.evmjdbc.Driver
import com.evmjdbc.exceptions.ErrorCode
import com.evmjdbc.exceptions.EvmSqlException
import com.evmjdbc.metadata.EvmDatabaseMetaData
import com.evmjdbc.metadata.VirtualSchema
import com.evmjdbc.rpc.RpcClient
import com.evmjdbc.rpc.RpcRequest
import com.evmjdbc.statement.EvmPreparedStatement
import com.evmjdbc.statement.EvmStatement
import org.slf4j.LoggerFactory
import java.sql.*
import java.util.Properties
import java.util.concurrent.Executor

/**
 * JDBC Connection implementation for EVM blockchain RPC.
 * This is a read-only connection that translates SQL queries to RPC calls.
 */
class EvmConnection(
    private val properties: ConnectionProperties
) : Connection {
    private val logger = LoggerFactory.getLogger(EvmConnection::class.java)

    private var closed = false
    private var autoCommit = true
    private var warnings: SQLWarning? = null
    private var holdability = ResultSet.CLOSE_CURSORS_AT_COMMIT
    private var networkTimeout = properties.timeout
    private var clientInfo = Properties()

    // Lazy initialization of RPC client
    internal val rpcClient: RpcClient by lazy {
        RpcClient(properties.rpcUrl, properties)
    }

    // Cached chain ID from initial connection validation
    private var chainId: Long? = null

    // Connection properties accessor
    internal val connectionProperties: ConnectionProperties get() = properties

    /**
     * Create a Statement object for sending SQL statements.
     */
    override fun createStatement(): Statement {
        checkOpen()
        return EvmStatement(this)
    }

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement {
        checkOpen()
        validateResultSetType(resultSetType)
        validateResultSetConcurrency(resultSetConcurrency)
        return EvmStatement(this)
    }

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement {
        checkOpen()
        validateResultSetType(resultSetType)
        validateResultSetConcurrency(resultSetConcurrency)
        return EvmStatement(this)
    }

    /**
     * Create a PreparedStatement object for sending parameterized SQL statements.
     */
    override fun prepareStatement(sql: String?): PreparedStatement {
        checkOpen()
        requireNotNull(sql) { "SQL string cannot be null" }
        return EvmPreparedStatement(this, sql)
    }

    override fun prepareStatement(sql: String?, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement {
        checkOpen()
        requireNotNull(sql) { "SQL string cannot be null" }
        validateResultSetType(resultSetType)
        validateResultSetConcurrency(resultSetConcurrency)
        return EvmPreparedStatement(this, sql)
    }

    override fun prepareStatement(
        sql: String?,
        resultSetType: Int,
        resultSetConcurrency: Int,
        resultSetHoldability: Int
    ): PreparedStatement {
        checkOpen()
        requireNotNull(sql) { "SQL string cannot be null" }
        validateResultSetType(resultSetType)
        validateResultSetConcurrency(resultSetConcurrency)
        return EvmPreparedStatement(this, sql)
    }

    override fun prepareStatement(sql: String?, autoGeneratedKeys: Int): PreparedStatement {
        return prepareStatement(sql)
    }

    override fun prepareStatement(sql: String?, columnIndexes: IntArray?): PreparedStatement {
        return prepareStatement(sql)
    }

    override fun prepareStatement(sql: String?, columnNames: Array<out String>?): PreparedStatement {
        return prepareStatement(sql)
    }

    /**
     * Callable statements are not supported (no stored procedures).
     */
    override fun prepareCall(sql: String?): CallableStatement {
        throw SQLFeatureNotSupportedException("Callable statements not supported")
    }

    override fun prepareCall(sql: String?, resultSetType: Int, resultSetConcurrency: Int): CallableStatement {
        throw SQLFeatureNotSupportedException("Callable statements not supported")
    }

    override fun prepareCall(
        sql: String?,
        resultSetType: Int,
        resultSetConcurrency: Int,
        resultSetHoldability: Int
    ): CallableStatement {
        throw SQLFeatureNotSupportedException("Callable statements not supported")
    }

    override fun nativeSQL(sql: String?): String? {
        return sql // No translation needed
    }

    /**
     * This driver is always read-only; autoCommit has no effect but is tracked for JDBC compliance.
     */
    override fun setAutoCommit(autoCommit: Boolean) {
        checkOpen()
        this.autoCommit = autoCommit
    }

    override fun getAutoCommit(): Boolean {
        checkOpen()
        return autoCommit
    }

    /**
     * Commit is a no-op for read-only connections.
     */
    override fun commit() {
        checkOpen()
        if (autoCommit) {
            throw SQLException("Cannot commit with autoCommit enabled")
        }
        // No-op for read-only connection
    }

    /**
     * Rollback is a no-op for read-only connections.
     */
    override fun rollback() {
        checkOpen()
        if (autoCommit) {
            throw SQLException("Cannot rollback with autoCommit enabled")
        }
        // No-op for read-only connection
    }

    override fun rollback(savepoint: Savepoint?) {
        checkOpen()
        // No-op for read-only connection
    }

    /**
     * Close the connection and release resources.
     */
    override fun close() {
        if (!closed) {
            logger.debug("Closing EVM connection")
            rpcClient.close()
            closed = true
        }
    }

    override fun isClosed(): Boolean = closed

    /**
     * Get database metadata.
     */
    override fun getMetaData(): DatabaseMetaData {
        checkOpen()
        return EvmDatabaseMetaData(this)
    }

    /**
     * This connection is always read-only.
     */
    override fun setReadOnly(readOnly: Boolean) {
        checkOpen()
        if (!readOnly) {
            throw EvmSqlException(
                ErrorCode.READ_ONLY_VIOLATION,
                "EVM SQL Driver is permanently read-only"
            )
        }
    }

    override fun isReadOnly(): Boolean {
        checkOpen()
        return true // Always read-only
    }

    override fun setCatalog(catalog: String?) {
        checkOpen()
        // Ignored - single catalog
    }

    override fun getCatalog(): String? {
        checkOpen()
        return VirtualSchema.CATALOG_NAME.ifEmpty { null }
    }

    override fun setTransactionIsolation(level: Int) {
        checkOpen()
        // Read-only, transaction isolation has no practical effect
        if (level != Connection.TRANSACTION_NONE && level != Connection.TRANSACTION_READ_COMMITTED) {
            throw SQLException("Unsupported transaction isolation level: $level")
        }
    }

    override fun getTransactionIsolation(): Int {
        checkOpen()
        return Connection.TRANSACTION_READ_COMMITTED
    }

    override fun getWarnings(): SQLWarning? {
        checkOpen()
        return warnings
    }

    override fun clearWarnings() {
        checkOpen()
        warnings = null
    }

    /**
     * Add a warning to the warning chain.
     */
    internal fun addWarning(warning: SQLWarning) {
        if (warnings == null) {
            warnings = warning
        } else {
            warnings?.nextWarning = warning
        }
    }

    override fun getTypeMap(): MutableMap<String, Class<*>> {
        checkOpen()
        return mutableMapOf()
    }

    override fun setTypeMap(map: MutableMap<String, Class<*>>?) {
        checkOpen()
        // Ignored
    }

    override fun setHoldability(holdability: Int) {
        checkOpen()
        this.holdability = holdability
    }

    override fun getHoldability(): Int {
        checkOpen()
        return holdability
    }

    /**
     * Savepoints not supported for read-only connection.
     */
    override fun setSavepoint(): Savepoint {
        throw SQLFeatureNotSupportedException("Savepoints not supported for read-only connection")
    }

    override fun setSavepoint(name: String?): Savepoint {
        throw SQLFeatureNotSupportedException("Savepoints not supported for read-only connection")
    }

    override fun releaseSavepoint(savepoint: Savepoint?) {
        throw SQLFeatureNotSupportedException("Savepoints not supported for read-only connection")
    }

    override fun createClob(): Clob {
        throw SQLFeatureNotSupportedException("Clob not supported")
    }

    override fun createBlob(): Blob {
        throw SQLFeatureNotSupportedException("Blob not supported")
    }

    override fun createNClob(): NClob {
        throw SQLFeatureNotSupportedException("NClob not supported")
    }

    override fun createSQLXML(): SQLXML {
        throw SQLFeatureNotSupportedException("SQLXML not supported")
    }

    /**
     * Validate the connection by making an eth_chainId call.
     */
    override fun isValid(timeout: Int): Boolean {
        if (closed) return false

        return try {
            val request = RpcRequest.ethChainId()
            val response = rpcClient.execute(request)

            if (response.isSuccess()) {
                val result = response.resultAsString()
                chainId = result?.removePrefix("0x")?.toLongOrNull(16)
                logger.debug("Connection validated, chain ID: {}", chainId)
                true
            } else {
                logger.warn("Connection validation failed: {}", response.error?.message)
                false
            }
        } catch (e: Exception) {
            logger.warn("Connection validation failed: {}", maskSensitiveData(e.message ?: "Unknown error"))
            false
        }
    }

    /**
     * Get the chain ID from the connected network.
     */
    fun getChainId(): Long? {
        if (chainId == null) {
            isValid(5) // Populate chainId
        }
        return chainId
    }

    override fun setClientInfo(name: String?, value: String?) {
        checkOpen()
        if (name != null && value != null) {
            clientInfo[name] = value
        }
    }

    override fun setClientInfo(properties: Properties?) {
        checkOpen()
        clientInfo.clear()
        properties?.let { clientInfo.putAll(it) }
    }

    override fun getClientInfo(name: String?): String? {
        checkOpen()
        return clientInfo.getProperty(name)
    }

    override fun getClientInfo(): Properties {
        checkOpen()
        return Properties().apply { putAll(clientInfo) }
    }

    override fun createArrayOf(typeName: String?, elements: Array<out Any>?): java.sql.Array {
        throw SQLFeatureNotSupportedException("Arrays not supported")
    }

    override fun createStruct(typeName: String?, attributes: Array<out Any>?): Struct {
        throw SQLFeatureNotSupportedException("Structs not supported")
    }

    override fun setSchema(schema: String?) {
        checkOpen()
        // Only "evm" schema is valid
        if (schema != null && !schema.equals(VirtualSchema.SCHEMA_NAME, ignoreCase = true)) {
            throw SQLException("Unknown schema: $schema")
        }
    }

    /**
     * Get the current schema (always "evm").
     */
    override fun getSchema(): String {
        checkOpen()
        return VirtualSchema.SCHEMA_NAME
    }

    override fun abort(executor: Executor?) {
        close()
    }

    override fun setNetworkTimeout(executor: Executor?, milliseconds: Int) {
        checkOpen()
        networkTimeout = milliseconds
    }

    override fun getNetworkTimeout(): Int {
        checkOpen()
        return networkTimeout
    }

    override fun <T : Any?> unwrap(iface: Class<T>?): T {
        if (iface != null && iface.isInstance(this)) {
            @Suppress("UNCHECKED_CAST")
            return this as T
        }
        throw SQLException("Cannot unwrap to ${iface?.name}")
    }

    override fun isWrapperFor(iface: Class<*>?): Boolean {
        return iface?.isInstance(this) == true
    }

    /**
     * Check that the connection is open.
     */
    private fun checkOpen() {
        if (closed) {
            throw EvmSqlException(ErrorCode.CONNECTION_CLOSED, "Connection is closed")
        }
    }

    private fun validateResultSetType(type: Int) {
        if (type != ResultSet.TYPE_FORWARD_ONLY && type != ResultSet.TYPE_SCROLL_INSENSITIVE) {
            throw SQLFeatureNotSupportedException("ResultSet type not supported: $type")
        }
    }

    private fun validateResultSetConcurrency(concurrency: Int) {
        if (concurrency != ResultSet.CONCUR_READ_ONLY) {
            throw SQLFeatureNotSupportedException("Only CONCUR_READ_ONLY is supported")
        }
    }

    /**
     * Mask sensitive data in messages for logging.
     */
    private fun maskSensitiveData(message: String): String {
        return message.replace(Regex("(api[_-]?key|key|token|secret|password)=([^&\\s]+)", RegexOption.IGNORE_CASE)) {
            "${it.groupValues[1]}=***"
        }
    }
}
